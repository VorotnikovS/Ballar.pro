<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Ballar ‚Äî Rive Site</title>
  <script src="https://unpkg.com/@rive-app/webgl"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background-color: black;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <canvas id="rive-canvas"></canvas>

  <script>
    const canvas = document.getElementById("rive-canvas");

    // üëá –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –º–æ–±–∏–ª—å–Ω–æ–µ –ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

    // üëá –£–º–µ–Ω—å—à–∞–µ–º –Ω–∞–≥—Ä—É–∑–∫—É: –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º DPR
    const dpr = isMobile ? 1 : Math.min(window.devicePixelRatio || 1, 1.5);
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    canvas.style.width = "100vw";
    canvas.style.height = "100vh";

    // üëá –í—ã–±–∏—Ä–∞–µ–º –ø–æ–¥—Ö–æ–¥—è—â–∏–π .riv —Ñ–∞–π–ª
    const riveFilePath = isMobile ? "ballar_mobile.riv" : "ballar.riv";

    let scrollYInput, goToWWInput, goToMathInput, ButtonBackInput;
    let goAppStoreWWInput, GoGooglePlayMathInput, GoAppStoreMathInput;

    const riveInstance = new rive.Rive({
      src: riveFilePath,
      canvas: canvas,
      autoplay: true,
      artboard: "Ballar",
      stateMachines: ["State Machine 1"],
      layout: new rive.Layout({
        fit: isMobile ? rive.Fit.Contain : rive.Fit.FitWidth
        alignment: rive.Alignment.TopCenter
      }),
      onLoad: () => {
        console.log("‚úÖ Rive animation loaded.");

        const inputs = riveInstance.stateMachineInputs("State Machine 1");

        const sizeInput = inputs.find(i => i.name === "Size");
        if (sizeInput) {
          sizeInput.value = window.innerWidth;
          console.log("üìè –ü–µ—Ä–µ–¥–∞–Ω–æ –≤ Rive Size:", sizeInput.value);
        }

        scrollYInput = inputs.find(i => i.name === "ScrollY");
        ButtonBackInput = inputs.find(i => i.name === "ButtonBack");
        goToMathInput = inputs.find(i => i.name === "goToMath");
        goAppStoreWWInput = inputs.find(i => i.name === "GoAppStoreWW");
        goToWWInput = inputs.find(i => i.name === "GoToWW");
        GoGooglePlayMathInput = inputs.find(i => i.name === "GoGooglePlayMath");
        GoAppStoreMathInput = inputs.find(i => i.name === "GoAppStoreMath");

        monitorTriggerFlag();
      },
      onError: (err) => console.error("‚ùå –û—à–∏–±–∫–∞ Rive:", err)
    });

    // üîÑ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Ç—Ä–∏–≥–≥–µ—Ä–æ–≤ ‚Äî –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è
    function monitorTriggerFlag() {
      let needNext = false;

      if (goToWWInput?.value === true) {
        goToWWInput.value = false;
        animateScrollYTo(1285);
        needNext = true;
      }

      if (goToMathInput?.value === true) {
        goToMathInput.value = false;
        animateScrollYTo(2474);
        needNext = true;
      }

      if (ButtonBackInput?.value === true) {
        ButtonBackInput.value = false;
        animateScrollYTo(0);
        needNext = true;
      }

      if (goAppStoreWWInput?.value === true) {
        goAppStoreWWInput.value = false;
        window.open("https://apps.apple.com/ru/app/wake-the-world-my-map/id1529898421?l=en-GB", "_blank");
        needNext = true;
      }

      if (GoGooglePlayMathInput?.value === true) {
        GoGooglePlayMathInput.value = false;
        window.open("https://play.google.com/store/apps/details?id=com.math.mastery", "_blank"); // –ó–∞–º–µ–Ω–∏—Ç—å
        needNext = true;
      }

      if (GoAppStoreMathInput?.value === true) {
        GoAppStoreMathInput.value = false;
        window.open("https://apps.apple.com/us/app/math-game-mental-mastery/id6745556295", "_blank");
        needNext = true;
      }

      if (needNext) {
        requestAnimationFrame(monitorTriggerFlag);
      } else {
        setTimeout(monitorTriggerFlag, isMobile ? 300 : 150); // –ú–æ–±–∏–ª—å–Ω—ã–º ‚Äî —Ä–µ–∂–µ
      }
    }

    // üñ± –ü—Ä–æ–∫—Ä—É—Ç–∫–∞ –∫–æ–ª–µ—Å–∏–∫–æ–º
    window.addEventListener("wheel", (e) => {
      if (scrollYInput) {
        const scrollFactor = isMobile ? 0.15 : 0.3;
        scrollYInput.value += e.deltaY * scrollFactor;
        scrollYInput.value = Math.max(0, Math.min(4000, scrollYInput.value));
        console.log("üñ± ScrollY =", scrollYInput.value);
      }
    });

    // üìΩ –ü–ª–∞–≤–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è
    function animateScrollYTo(targetValue) {
      const duration = 600;
      const startValue = scrollYInput.value;
      const startTime = performance.now();

      function step(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = easeInOutQuad(progress);
        scrollYInput.value = startValue + (targetValue - startValue) * eased;
        if (progress < 1) requestAnimationFrame(step);
      }

      requestAnimationFrame(step);
    }

    function easeInOutQuad(t) {
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
  </script>
</body>
</html>
